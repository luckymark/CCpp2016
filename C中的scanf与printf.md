# C中的scanf与printf

## 为什么这两个函数叫这个名字

我们首先考虑一下这个问题，为什么这两个函数不叫scan和print

f-format
格式输入输出

## 格式是什么

先看到两个函数的原型

---

int scanf ( const char * format, ... );

**Read formatted data from stdin**
Reads data from stdin and stores them according to the parameter format into the locations pointed by the additional arguments.

The additional arguments should point to already allocated objects of the type specified by their corresponding format specifier within the format string.

---

int printf ( const char * format, ... );

**Print formatted data to stdout**
Writes the C string pointed by format to the standard output (stdout). If format includes format specifiers (subsequences beginning with %), the additional arguments following format are formatted and inserted in the resulting string replacing their respective specifiers.

## scanf

举一个最简单的例子

```
int a =1, b =2, c =3;int n = scanf("%d %d %d", &a, &b, &c);
printf("%d\n", n );printf("%d, %d, %d", a, b, c);
```

n保存了scanf的返回值
成功读取了几个变量就返回几，如果遇到错误则返回**EOF**
先解释一下EOF

--- 

#### 什么是EOF?

- 一般被定义为整数-1
- 是系统给出的一个信号（并不存在于文件）告诉你**没有数据**可以再进行读取了

#### 如何“制造”一个EOF?

- Windows: Ctrl+Z + Enter
- *nix: Ctrl+D

---

回到刚才的小程序，关键的一行代码
`scanf("%d %d %d", &a, &b, &c);`
这个**%d**就是**格式控制符**
还有很多其他的格式控制符，列举几个常用的

* %c 读入一个字符
* %d 读入十进制整数
* %i 读入十进制，八进制，十六进制整数
* %o 读入八进制整数
* %x,%X 读入十六进制整数
* %c 读入一个字符
* %s 读入一个字符串，遇空格、制表符或换行符结束。
* %f,%F,%e,%E,%g,%G 用来输入float，可以用小数形式或指数形式输入。double是类似的
* %p 读入一个指针
* %u 读入一个无符号十进制整数
* %n 至此已读入值的等价字符数
* %[] **正则表达式**
* %% 读%符号

对应每个

下面讲几个重要的

### %i

我也没用过
单独拿出来说
大家都知道%d是输入一个整数。确切的说是输入一个十进制整数
这个标识符可以读入16进制与8进制的数并转化成十进制整数存储

### 64位整数

变量定义

- Windows: __int64 (gcc/高版本vs中貌似也可以用long long)
- *nix: long long 

输出格式

- Windows: I64d
- *nix: lld

### long double 类型

long double 在C99之后成为正式的关键字
精度由编译器决定,有的是和double一样的8位,有的是10/12/16位
使用sizeof(long double)查看

使用**%Lf**或者**%llf**

这些常用的格式控制符是scanf/printf都拥有相同功能的（把读入换成输出就行了）

---

### 除了格式控制符以外还能有什么呢

* “空格”（包括tab和换行符）
* 不是格式控制符的普通字符

遇到空格：不论有几个空格的效果都是一样的，作用是跳过缓冲区中的空格字符直到当前字符不是空格

普通字符：比较这个字符是不是等于下一个字符。如果是的话就读入，不是的话就停止读入（函数直接返回）

```
int x=-1;
int n = scanf(" d%d",&x);
printf("%d\n%d",n,x);
```

```
int x=0;
while( scanf("%d ",&x) != EOF){
	printf("%d\n",x);
}
```

### 表达式贪心匹配

就是说每次匹配的数量尽可能的多，举个例子

```
char str[10];int x;
scanf("%s:%d",str,&x);
printf("%s %d\n",str,x);
//输入 ccpp:1234 7654321
//你预计输出 ccpp 1234
//但事实上输出 ccpp:1234 [未定义整数]
```

#### 小测试

```
char a[]="%d,%d",b[]="%d , %d",c[]="%d ,%d"; int x,y;
while( scanf( a, &x, &y)!= EOF){
	printf("%d, %d\n",x,y);
}
```

```
1,2
3 ,4
5, 6
7 , 8
9 10
```

### 正则表达式的使用

由于这个贪心匹配的规则，让字符串的匹配不是那么容易直接得到想要的结果，这个时候就要用上正则表达式来进行高级匹配

插播一下正则表达式学习资源：
[著名的正则表达式三十分钟入门](http://deerchao.net/tutorials/regex/regex.htm)
[在线测试](http://snowcoal.com/tools/regex/reg)

最简单的应用

定制自己的扫描集`%[abc]、%[a-z]、%[^abc]、%[^a-z]`，比isdigit()、isalpha()更加灵活。[]内是匹配的字符,^表示求反集。

举个例子

```
char str[10],str2[10];int x=0;
scanf("%[^#]%s",str,str2);
printf("%s|%s",str,str2);
\\输入 ccpp 2#uestc
\\输出 ccpp 2|#uestc
```

这个表达式的意思是匹配到第一个不是'#'号的内容为止
很容易发现这个'#'并没有被丢弃，只是匹配停止了而已

前两天提到一个问题，如何用scanf读取一整行内容
很容易想到使用`%[^\n]`即读取到换行符为止
那么问题就来了

- 历史遗留问题：`\n`与`\r`
- 这一行并没有真正的被读取

不管怎么说，`\n`还没有地方放呢。如果你以为这一行已经读完了，Boom
我们要尽可能的让程序**鲁棒**
所以推荐使用fgets(,,)安全方便快捷

以上先放一边，继续看格式控制符

---

现在告诉你一个格式控制符完整的样子
`%[*][width][length]specifier`
*号的作用是读入这个格式控制符代表的数但是不存储（非常有用）
width是一个整数用来控制这次读入的字符长度
length有这么几个可选值：hh, h, l, ll, j, z, t, L 用来操纵读入数据在内存中的长度

> 注意：以上三个部分都是可选的

那么格式控制符基本介绍完啦

---

### 如何输入多组数据

当输入的个数你无法预先只知道的时候，我们就要用到刚刚说的EOF啦
我们来看一段程序

```
int x = 0;while( scanf("%d", &x) != EOF ){	... 
}
```

看起来非常完美（并不
我们看看能不能制造一点问题出来

输入一些非数字进去看看会是神马结果：%T@#$@KI

进入了死循环...

为什么会这样呢

因为每一次的scanf都失败了，返回了0，然而程序并没有停下来...

来一段学术一点的文字

**scanf函数是以删除的方式从缓冲区读取数据(缓冲区中存储来自标准输入的数据)。**如果缓冲区是空的，就阻塞之，等待从键盘输入；并且scanf还能对数字输入忽略先导的空白符，如\n\t和空格等(注意，对字符输入并不忽略先导字符，这个也是很自然的道理，因为\n\t和空格在字符中都是合法的字符)。

聪明的你一定已经知道如何正确的读取多组数据了吧


## printf

### 返回值

```
int count = printf("This is a test!\n");
printf("%d\n", count);
\\This is a test!
\\16
```

返回输出字符的数量

### 格式控制符

我们已经有了scanf的知识了，这部分就很简单了

`%[flags][width][.precision][length]specifier`
`%[标志][宽度][.精度][长度修饰]类型`

稍微比scanf多一点东西。比较我们要控制输出嘛

### 类型

与scanf基本相同，只是简单类型不需要再传地址而是传值了
那么我来讲几个不同的

> C99加入了一坨东西，这里不说了，就现在来说没什么意思
 
> 浮点数的默认保留小数点后的6位（是怎么保留的呢，我们之后再讲）

#### %f问题

读入的时候float与double是不同的控制符，但是在原来的标准中输出统一用%f，在某些编译器上用%lf输出double会RE/WA

#### %p问题

输出指针的十六进制标准格式

```
int a=0;
printf("%p", &a);
\\0x7fff5cdf57ec
\\我是64位机器
```

#### %n问题

这个并不是输出标识符，而是需要你传给printf一个指向int类型的指针，printf会放入一个整数表示已经输出了多少个字符

```
char str[]="uestc";
int len;
printf("%s%n-ccpc\n", str, &len);
printf("%d\n",len);
\\uestc-ccpc
\\5
```

### 宽度

有两种选择

#### 整数

指定了输出宽度

```
int a=2, b=10;
printf("%d%5d", a, b);
\\2   10
```

#### 星号

由一个参数决定输出宽度

```
int a=2, width=3;
printf("%*d",width, a);
\\  2
```

### 精度

这个参数是控制浮点数精度的，经常搭配宽度使用，同样可以用星号来用参数决定宽度，这里不再赘述

重点是：程序是如何进行舍入的

#### 先看一个例子

```
printf("%.2f, %.2f\n", 9.805, 9.8051);
printf("%.2f, %.2f\n", 9.815, 9.8151);
printf("%.2f, %.2f\n", 9.825, 9.8251);
printf("%.2f, %.2f\n", 9.835, 9.8351);
printf("%.2f, %.2f\n", 9.845, 9.8451);
printf("%.2f, %.2f\n", 9.855, 9.8551);
printf("%.2f, %.2f\n", 9.865, 9.8651);
printf("%.2f, %.2f\n", 9.875, 9.8751);
printf("%.2f, %.2f\n", 9.885, 9.8851);
printf("%.2f, %.2f\n", 9.895, 9.8951);
```

```
9.80, 9.81
9.81, 9.82
9.82, 9.83
9.84, 9.84
9.85, 9.85
9.86, 9.86
9.87, 9.87
9.88, 9.88
9.88, 9.89
9.89, 9.90
```

#### Banker’s rounding

> 1. 被修约的数字等于或小于4时，该数字舍去；
> 2. 被修约的数字等于或大于6时，则进位；
> 3. 被修约的数字等于5时，要看5前面的数字，若是奇数则进位，若是偶数则将5舍掉，即修约后末尾数字都成为偶数；若5的后面还有不为“0”的任何数，则此时无论5的前面是奇数还是偶数，均应进位。

回到刚才的输出结果

貌似并不完全符合这个规律，不管5前面是奇数还是偶数，都出现了进位和舍去的情况。猜想这应该与浮点型在计算机中采用二进制存储有关。对有些无法由二进制有限表示的小数，超出浮点数尾数的部分将被直接舍去，造成了输出不稳定的现象。但是这种解释将使数值在Banker’s rounding 的基础上一定变小，而显然9.845变成9.85并不满足，原因不明。当然也有可能超出浮点数尾部的部分并不是直接舍去，而也是采取了四舍五入的方法，暂时没有找到资料支撑。

如果真的需要四舍五入，我们在数字不大的时候用math库中的round()，在数字很大的时候用sprintf/sscanf手工处理

### 标志位

#### -
 
配合宽度使用，向左对齐

```
char buf[] = "Test";
printf("%-10s");
\\"Test      "(6个空格)
```
         
#### + 

数值类型专用，强制输出正负号，可以与上面的‘-’合用

```
double a = 3.4567:
printf("%-+8.2lf", a); 
\\"+3.46   "
```

#### 0 

若前半部分有空白，补充前导零

```
unsigned int x = 122;
printf("%05u", x); 
\\"00122"
```

#### 井号

只对于 %o, %x 有用, 加上进制的前缀
%#o前缀为0, %#x前缀为 0x, %#X前缀为 0X

```
unsigned int a = 15;
printf("%u %#o %#X", a, a, a);
\\"15 017 0XF" 
```

#### %(空白)

数值专用，不能与‘+’合用。若输出为正数，留出一个空格的符号位

```
int a=10;
printf("% -5d");
\\" 10  "
```

---

那么scanf/printf的主要内容就讲完了

---

## 最后来吹个B

关于I/O流的
现象不是很好重现（现在机器太快了...），对平台要求比较高（说好听点就是比较隐蔽），就当是吹B了

我们知道系统给我们提供了三种标准I/O流: stdin,stdout,stderr
当然了，和文件流操作上是基本统一了

先引入**缓冲区**这个概念

比如我想把一篇文章以字符序列的方式输出到计算机显示器屏幕上，那么我的程序内存作为数据源而显示器驱动程序作为数据目标，如果数据源直接对数据目标发送数据的话。数据目标获得第一个字符，便将它显示。然后从端口读取下一个字符，可是这时就不能保证数据源向端口发送的恰好是第二个字符（也许是第三个，而第二个已经在数据目标显示时发送过了）。这样的话就不能保证输出的数据能完整的被数据目标所接受并处理。

为了解决这个问题，我们需要在数据源与数据目标中间放置一个保存完整数据内容的区域，那就是 “缓冲区”。这样的话， 数据源可以不考虑数据目标正在处理哪部分数据，只要把数据输出到缓冲区就可以了，数据目标也可以不考虑数据源的发送频率，只是从缓冲区中依次取出下一个数据。从而保证了数据发送的完整性，同时也提高了程序的效率。为什么说提高了效率呢？首先是两边操作不需要同步，再者也方便系统做对齐之类的工作，凑够一定量的字符一口气发出去。（瞎比乱说的）

回到这三种I/O流上来。对于输入，只有我们在按了回车键之后，屏幕上输入的内容才一次性的被传入缓冲区。（有人问：能不能实时的监测键盘输入呢？答案是肯定的。conin.h里的getch(),getche()就是这样的，直接操作控制台，和stdin没有任何关系）这就可以解释刚刚提到的scanf死循环啊什么的问题了。scanf并不是直接从屏幕上读取，而是从缓冲区内读取数据

那么同理，我们的输出也不是直接发到屏幕上的，而是发送到缓冲区内的。但是为什么我们看起来就像直接看到了呢？（因为计算机快啊。。。）那么我们想想，会不会存在一个问题：程序结束了，输出缓冲区的内容还没有完全到达输出流；或者是输出printf后无法立即接收到反馈信息呢（内部交互的程序）

所以在C语言中如果用的文件/重定向的标准输出，程序结束之前最好fclose(stdout);
如果写程序之间的交互要用fflush(stdout);当然你用cout<<endl;的时候就直接清除缓冲区了
清除stdin缓冲区用gets()

---

最后...

**以上都是前人的经验,踩过的坑**


